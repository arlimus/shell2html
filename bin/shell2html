#!/usr/bin/env ruby

require 'eventmachine'
require 'rb-readline'

module ExecSimple

  def exec_simple( cmd, itemizer = nil )

    cmd_escaped = cmd.gsub(/\\/,'\\\\\\\\').gsub(/["]/,'\"')
    cmd = "sh -c \"#{cmd_escaped}\""

    res = nil
    EM::run do
      res = EM::popen( cmd, ResultCache, itemizer )
    end
    res.items
  end

  private

  class ResultCache < EM::Connection
    include EM::Protocols::LineText2
    attr_reader :itemizer, :items

    def initialize(itemizer)
      @items = []
      @itemizer = lambda {|i| i }
      @itemizer = itemizer if itemizer.is_a?(Proc)
    end

    def receive_line(data)
      @items.push @itemizer.(data)
    end

    def unbind
      EM::stop
    end
  end

end


# hotfix broken CTRL+forward/backward in shell
# (at least on my keyboard layout, where the default input has bold-style)
# (ie ansi-escape \e[1m which is not read correctly)
module Readline
  def self.set_key_to x, y
    RbReadline.rl_bind_keyseq_if_unbound(x,y)
  end
end
Readline::set_key_to "\033[1;5C", :rl_forward_word
Readline::set_key_to "\033[1;5D", :rl_backward_word


class Shell2Html
  include ExecSimple

  def initialize output = nil, options
    @output = output
    @options = options
    @cache = []
    @html = ""
  end

  def repl
    # http://bogojoker.com/readline/
    stty_save = `stty -g`.chomp
    trap('INT') do
      system('stty', stty_save)
      finish
    end


    loop do
      line = Readline::readline('> ')
      break if line.nil?
      Readline::HISTORY.push(line)
      run line
    end
  end

  def run cmd
    if cmd == 'exit' or cmd == 'quit'
      finish
    end

    r = exec_simple cmd, lambda{|i|
      puts i
      i
    }

    @cache.push([cmd, r.join("\n")])
  end

  def finish
    opts_bg = ( @options[:bg].nil? or @options[:bg] != 'dark' ) ? '' : "--bg=dark"
    opts_palette = ( @options[:palette].nil? ) ? '' : "--palette=#{@options[:palette]}"

    IO.popen("ansi2html #{opts_bg} #{opts_palette}",'r+') do |pipe|
      @cache.each do |cc|
        pipe.puts("> #{cc[0]}")
        pipe.puts(cc[1])
        pipe.puts(SEPARATOR)
      end
      pipe.close_write
      @html = pipe.read.gsub /#{SEPARATOR}/, "\n<hr/>\n"
    end

    if @output.nil?
      puts @html
    else
      File::write @output, @html
    end

    exit 0
  end

  private

  SEPARATOR = "THIS_IS_A_HUGE_HONKING_SEPARATOR_WHICH_IS_TURNED_INTO_A_HORIZONTAL_RULE"
end


require 'trollop'
opts = Trollop::options do
  opt :bg, "Set the background to light or dark", type: :string
  opt :palette, "color palette for ansi2html (linux|solarized|tango|xterm)", type: :string
  banner <<-EOS
Usage: shell2html [outfile] [options]+
where [options] are:
EOS
end

outfile = nil
if ARGV.length > 0
  outfile = ARGV[0]
  puts "saving to: #{outfile}"
end
Shell2Html.new(outfile, opts).repl
